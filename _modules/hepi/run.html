<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hepi.run &mdash; HEPi  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/thebelab.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> HEPi
          </a>
              <div class="version">
                0.2.8
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Versions:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://apn-pucky.github.io/HEPi/">Stable</a></li>
<li class="toctree-l1"><a class="reference external" href="https://apn-pucky.github.io/HEPi/test/">Dev</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links:</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/APN-Pucky/HEPi">GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/demo_resummino.html">Resummino example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test_distribute.html">Distribute resummino run files to clusters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test_interpolate.html">Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test_madgraph.html">MadGraph example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test_pyslha.html">pyslha comparison</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test_spheno.html">SPheno example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/test_write.html">Result writing example</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Module:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/hepi/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hepi</span></code></a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HEPi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
          <li><a href="../hepi.html">hepi</a> &raquo;</li>
      <li>hepi.run</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hepi.run</h1><div class="highlight"><pre>
<span></span>from concurrent.futures import ThreadPoolExecutor
from logging import warning
import os
import subprocess
from subprocess import Popen, PIPE
from typing import List
import warnings

import numpy as np
from hepi.input import Input, Order, get_input_dir, get_output_dir, get_pre
from hepi.results import Result
from hepi.util import DL2DF, LD2DL, DictData, namehash
from smpl.parallel import par
import time
import tqdm
from pqdm.threads import pqdm as tpqdm
from pqdm.processes import pqdm as ppqdm
import multiprocessing as mp
#from pqdm.processes import pqdm

<div class="viewcode-block" id="RunParam"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.RunParam">[docs]</a>class RunParam(DictData):
    &quot;&quot;&quot;Abstract class that is similar to a dictionary but with fixed keys.&quot;&quot;&quot;

    def __init__(self,
                 skip: bool = False,
                 in_file: str = None,
                 out_file: str = None,
                 execute: str = None,
                 name: str = None):
        self.name = name
        self.skip = skip
        self.in_file = in_file
        self.out_file = out_file
        self.execute = execute</div>


<div class="viewcode-block" id="Runner"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner">[docs]</a>class Runner:

    def __init__(self,
                 path: str,
                 in_dir: str = None,
                 out_dir: str = None,
                 pre=None):
        self.path = path
        if in_dir is None:
            self.in_dir = get_input_dir()
        else:
            self.in_dir = in_dir
        if out_dir is None:
            self.out_dir = get_output_dir()
        else:
            self.out_dir = out_dir
        if pre is None:
            self.pre = get_pre()
        else:
            self.pre = pre

<div class="viewcode-block" id="Runner.orders"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.orders">[docs]</a>    def orders(self) -&gt; List[Order]:
        &quot;&quot;&quot;List of supported Orders in this runner.&quot;&quot;&quot;
        return [e.value for e in Order]</div>

<div class="viewcode-block" id="Runner.get_name"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.get_name">[docs]</a>    def get_name(self) -&gt; str:
        &quot;&quot;&quot;Returns the name of the runner.&quot;&quot;&quot;
        return type(self).__name__</div>

<div class="viewcode-block" id="Runner.get_version"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.get_version">[docs]</a>    def get_version(self) -&gt; str:
        return &quot;?&quot;</div>

<div class="viewcode-block" id="Runner._sub_run"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner._sub_run">[docs]</a>    def _sub_run(self, coms: List[str]) -&gt; str:
        process = Popen(coms, stdout=PIPE)
        (output, err) = process.communicate()
        exit_code = process.wait()
        if exit_code != 0:
            return err.decode()
        else:
            return output.decode()</div>

<div class="viewcode-block" id="Runner._check_path"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner._check_path">[docs]</a>    def _check_path(self) -&gt; bool:
        &quot;&quot;&quot;Checks if the passed path is valid.&quot;&quot;&quot;
        return True</div>

<div class="viewcode-block" id="Runner._prepare"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner._prepare">[docs]</a>    def _prepare(self, p: Input, skip=False, assume_valid = False, **kwargs) -&gt; RunParam:
        skip_ = skip
        #p.runner = str(type(self).__name__) + &quot;-&quot; + self.get_version()

        d = p.__dict__
        #d[&quot;runner&quot;] = str(type(self).__name__) + &quot;-&quot; + self.get_version(
        #)  # TODO re add version, but removed for reusable hashing!
        name = namehash(&quot;_&quot;.join(&quot;&quot;.join(str(_[0]) + &quot;_&quot; + str(_[1]))
                                 for _ in d.items()).replace(&quot;/&quot;, &quot;-&quot;))
        #print(name)
        skip = False
        if skip_ and os.path.isfile(self.get_output_dir() + name + &quot;.out&quot;) and (assume_valid or self._is_valid(
                                        self.get_output_dir() + name + &quot;.out&quot;,
                                        p,
                                        d,
                                        skip=skip_,
                                        **kwargs)):
            #print(&quot;.&quot;, end=&#39;&#39;)
            skip = True
        else:
            #print(str(self.get_output_dir()  + name + &quot;.out&quot;)) 
            #print(&#39;|&#39;, end=&#39;&#39;)
            skip = False
        return RunParam(execute=self.get_output_dir() + name + &quot;.sh&quot;,
                        in_file=self.get_output_dir() + name + &quot;.in&quot;,
                        out_file=self.get_output_dir() + name + &quot;.out&quot;,
                        skip=skip,
                        name=name)</div>

<div class="viewcode-block" id="Runner._check_input"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner._check_input">[docs]</a>    def _check_input(self, param: Input, **kwargs) -&gt; bool:
        if param.order not in self.orders():
            warnings.warn(&quot;Order &quot; + str(param.order) + &quot; not supported in &quot; +
                          type(self).__name__)
            return False
        return True</div>

<div class="viewcode-block" id="Runner._prepare_all"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner._prepare_all">[docs]</a>    def _prepare_all(self,
                     params: List[Input],
                     skip=True,
                     n_jobs = None,
                     **kwargs) -&gt; List[RunParam]:
        &quot;&quot;&quot;
        Prepares all parameters for execution.

        Args:
            params (List[:class:`hepi.Input`]): List of input parameters.
            skip (bool, optional): If True, the runner will check if the output file already exists and skip the execution if it does. Defaults to True.
            n_jobs (int): Number of parallel jobs. If None, use all available cores.
        &quot;&quot;&quot;
        ret = []

        #ret = my_parallel(self._check_input,params,desc=&quot;Checking input&quot;)
        ret = tpqdm(params,
                    self._check_input,
                    n_jobs=n_jobs if n_jobs is not None else mp.cpu_count(),
                    desc=&quot;Checking input&quot;)
        if not np.alltrue(ret):
            warnings.warn(&quot;Check input failed.&quot;)
            return []
        #ret = my_parallel(
        #    lambda p: self._prepare(p, skip=skip, **kwargs),
        #    params,
        #    #n_jobs=mp.cpu_count(),
        #    desc=&quot;Preparing&quot;)
        runnername = str(type(self).__name__) + &quot;-&quot; + self.get_version()
        for p in params: p.runner = runnername
        args = [{&#39;p&#39;: p, &#39;skip&#39;: skip, **kwargs} for p in params]
        ret = ppqdm(args,
                    self._prepare,
                    n_jobs=n_jobs if n_jobs is not None else mp.cpu_count(),
                    argument_type=&#39;kwargs&#39;,
                    desc=&quot;Preparing&quot;)
        skipped = 0
        not_skipped = 0
        for r in ret:
            if r.skip:
                skipped += 1
            else:
                not_skipped += 1
        print(&quot;Skipped: &quot; + str(skipped) + &quot; Not skipped: &quot; + str(not_skipped))
        #for p in params:
        #    if not self._check_input(p):
        #        warnings.warn(&quot;Check input failed.&quot;)
        #        return []
        #    ret.append(self._prepare(p, skip=skip, **kwargs))
        return ret</div>

<div class="viewcode-block" id="Runner.run"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.run">[docs]</a>    def run(self,
            params: List[Input],
            skip=True,
            parse=True,
            parallel=True,
            sleep=0,
            run=True,
            ignore_error=False,
            n_jobs = None,
            **kwargs):
        &quot;&quot;&quot;
		Run the passed list of parameters.

		Args:
		    params (:obj:`list` of :class:`hepi.Input`): All parameters that should be executed/queued.
		    skip (bool): True means stored runs will be skipped. Else the are overwritten.
		    parse (bool): Parse the results. 
		        This is not the prefered cluster/parallel mode, as there the function only queues the job.
		    parallel (bool): Run jobs in parallel.
		    sleep (int): Sleep seconds after starting job.
            run (bool): Actually start/queue runner.
            ignore_error (bool): Continue instead of raising Exceptions. Also ignores hash collisions.
            n_jobs (int): Number of parallel jobs. If None, use all available cores.

		Returns:
		    :obj:`pd.DataFrame` : combined dataframe of results and parameters. The dataframe is empty if `parse` is set to False.

		&quot;&quot;&quot;
        if not self._check_path():
            warnings.warn(&quot;The path is not valid for &quot; + self.get_name())
            if not ignore_error:
                raise RuntimeError(&quot;The path is not valid for &quot; +
                                   self.get_name())
        rps = self._prepare_all(params,
                                parse=parse,
                                skip=skip,
                                ignore_error=ignore_error,
                                n_jobs=n_jobs,
                                **kwargs)
        #print(&quot;= &quot; + str(len(params)) + &quot; jobs&quot;)
        if sleep is None:
            sleep = 0 if parse else 5
        if run:
            self._run(rps,
                      wait=parse,
                      parallel=parallel,
                      sleep=sleep,
                      n_jobs = n_jobs,
                      **kwargs)
        if parse:
            outs = LD2DL(rps)[&quot;out_file&quot;]
            results = self.parse(outs,n_jobs=n_jobs)
            rdl = LD2DL(results)
            pdl = LD2DL(params)
            return DL2DF({**rdl, **pdl})
        return DL2DF({})</div>

<div class="viewcode-block" id="Runner._run"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner._run">[docs]</a>    def _run(self,
             rps: List[RunParam],
             wait=True,
             parallel=True,
             sleep=0,
             n_jobs = None,
             **kwargs):
        &quot;&quot;&quot;
		Runs Runner per :class:`RunParams`.
	
		Args:
		    rps (:obj:`list` of :class:`RunParams`): Extended run parameters.
		    bar (bool): Enable info bar.
		    wait (bool): Wait for parallel runs to finish.
		    sleep (int): Sleep seconds after starting subprocess.
		    parallel (bool): Run jobs in parallel.
            n_jobs (int): Number of parallel jobs. If None, use all available cores.
	
		Returns:
		    :obj:`list` of int: return codes from jobs if `no_parse` is False.
		&quot;&quot;&quot;
        # get cluster or niceness prefix
        template = self.get_pre() + &quot; &quot; + &quot;{}&quot;

        # Run commands in parallel
        processes = []
        cmds = []

        for rp in rps:
            if not rp.skip:
                command = template.format(rp.execute)
                cmds.append(command)

        if wait and parallel:
            return tpqdm(cmds,
                  lambda c: subprocess.call(c,shell=True),
                  n_jobs=n_jobs if n_jobs is not None else mp.cpu_count(),
                  desc=&quot;Running&quot;)
            #with ThreadPoolExecutor(max_workers=n_jobs if n_jobs is not None else mp.cpu_count()) as executor:
            #    for cmd in cmds:
            #        processes.append(executor.submit(subprocess.call, cmd, shell=True))
            #        time.sleep(sleep)
            #    return [p.result() for p in processes]

        for command in cmds:
            command = template.format(rp.execute)
            process = subprocess.Popen(command, shell=True)
            processes.append(process)
            if not parallel:
                process.wait()
            # Forced delay to prevent overloading clusters when registering jobs
            time.sleep(sleep)

        if wait:
            # Collect statuses
            output = [p.wait() for p in processes]
            return output
        return []</div>

<div class="viewcode-block" id="Runner._is_valid"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner._is_valid">[docs]</a>    def _is_valid(self, file: str, p: Input, d, **kwargs) -&gt; bool:
        &quot;&quot;&quot;
		Verifies that a file is a complete output.
	
		Args:
		    file (str): File path to be parsed.
		    p (:class:`hepi.Input`): Onput parameters.
		    d (:obj:`dict`): Param dictionary.
	
		Returns:
		    bool : True if `file` could be parsed.
		&quot;&quot;&quot;
        res = self._parse_file(file)
        if res.LO is None and p.order is Order.LO:
            return False
        if res.NLO is None and p.order is Order.NLO:
            return False
        if res.NLO_PLUS_NLL is None and p.order is Order.NLO_PLUS_NLL:
            return False
        if res.aNNLO_PLUS_NNLL is None and p.order is Order.aNNLO_PLUS_NNLL:
            return False
        return True</div>

<div class="viewcode-block" id="Runner.parse"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.parse">[docs]</a>    def parse(self, outputs: List[str],n_jobs=None) -&gt; List[Result]:
        &quot;&quot;&quot;
		Parses Resummino output files and returns List of Results.
	
		Args:
		    outputs (:obj:`list` of `str`): List of the filenames to be parsed.
            n_jobs (int): Number of parallel jobs. If None, use all available cores.
	
		Returns:
		    :obj:`list` of :class:`hepi.resummino.result.ResumminoResult`
	
		&quot;&quot;&quot;
        rsl = []
        #for r in parallel(self._parse_file, outputs):
        #    rsl.append(r)

        # parallelized opens to many files at times
        #rsl = my_parallel(self._parse_file, outputs, desc=&quot;Parsing&quot;)
        rsl = tpqdm(outputs,
                   self._parse_file,
                   n_jobs=n_jobs if n_jobs is not None else mp.cpu_count(),
                   desc=&quot;Parsing&quot;)
        return rsl</div>
        #for o in tqdm.tqdm(outputs):
        #    rsl.append(self._parse_file(o))
        #return rsl

<div class="viewcode-block" id="Runner._parse_file"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner._parse_file">[docs]</a>    def _parse_file(self, file: str) -&gt; Result:
        &quot;&quot;&quot;
		Extracts results from an output file.

		Args:
		    file (str): File path to be parsed.

		Returns:
		    :class:`Result` : If a value is not found in the file None is used.

		&quot;&quot;&quot;
        return None</div>

<div class="viewcode-block" id="Runner.get_path"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.get_path">[docs]</a>    def get_path(self) -&gt; str:
        &quot;&quot;&quot;
		Get the Runner path.

		Returns:
		    str: current Runner path.
		&quot;&quot;&quot;
        return self.path</div>

<div class="viewcode-block" id="Runner.get_input_dir"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.get_input_dir">[docs]</a>    def get_input_dir(self) -&gt; str:
        &quot;&quot;&quot;
		Get the input directory.

		Returns:
		    str: :attr:`in_dir`
		&quot;&quot;&quot;
        return self.in_dir</div>

<div class="viewcode-block" id="Runner.get_output_dir"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.get_output_dir">[docs]</a>    def get_output_dir(self) -&gt; str:
        &quot;&quot;&quot;
		Get the input directory.

		Returns:
		    str: :attr:`out_dir`
		&quot;&quot;&quot;
        return self.out_dir</div>

<div class="viewcode-block" id="Runner.get_pre"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.get_pre">[docs]</a>    def get_pre(self) -&gt; str:
        &quot;&quot;&quot;
		Gets the command prefix.

		Returns:
		    str: :attr:`pre`
		&quot;&quot;&quot;
        return self.pre</div>

<div class="viewcode-block" id="Runner.set_path"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.set_path">[docs]</a>    def set_path(self, p: str):
        &quot;&quot;&quot;
		Set the path to the Runner folder containing the binary in &#39;./bin&#39; or &#39;./build/bin&#39;.

		Args:
		    p (str): new path.
		&quot;&quot;&quot;
        if os.path.isdir(p):
            self.path = p + (&quot;/&quot; if p[-1] != &quot;/&quot; else &quot;&quot;)
        self.path = p</div>

<div class="viewcode-block" id="Runner.set_input_dir"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.set_input_dir">[docs]</a>    def set_input_dir(self, indir: str):
        &quot;&quot;&quot;
		Sets the input directory.

		Args:
		    indir (str): new input directory.
		&quot;&quot;&quot;
        self.in_dir = indir</div>

<div class="viewcode-block" id="Runner.set_output_dir"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.set_output_dir">[docs]</a>    def set_output_dir(self, outdir: str, create: bool = True):
        &quot;&quot;&quot;
		Sets the output directory.

		Args:
		    outdir (str): new output directory.
			create (bool): create directory if not existing.
		&quot;&quot;&quot;
        if create:
            os.makedirs(outdir, exist_ok=True)
        self.out_dir = outdir</div>

<div class="viewcode-block" id="Runner.set_pre"><a class="viewcode-back" href="../../autoapi/hepi/run/index.html#hepi.Runner.set_pre">[docs]</a>    def set_pre(self, ppre: str):
        &quot;&quot;&quot;
		Sets the command prefix.

		Args:
		    ppre (str): new command prefix.
		&quot;&quot;&quot;
        self.pre = ppre</div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, APN-Pucky.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>